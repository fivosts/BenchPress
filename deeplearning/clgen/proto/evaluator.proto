// The file defines the protos for specificying the evaluation of BenchPress.
syntax = "proto2";

package clgen;

option go_package = "clgenpb";
option java_multiple_files = true;
option java_outer_classname = "EvaluatorProto";
option java_package = "com.clgen";

// import "deeplearning/clgen/proto/model.proto";
// import "deeplearning/clgen/proto/corpus.proto";

// Specification of app's evaluation pipeline.
message Evaluation {
  // Define workspace path
  optional string     workspace = 1;
  // Define tokenizer path
  optional string     tokenizer = 2;
  // Define a list of different evaluators to run.
  repeated evaluators evaluator = 3;
}

// Instance of a single evaluation pass.
message evaluators {
  // Define all different evauators supported.
  oneof evaluator {
    LogFile                 log_file                  = 1;
    KAverageScore           k_average_score           = 2;
    MinScore                min_score                 = 3;
    AnalyzeTarget           analyze_target            = 4;
    CompMemGrewe            comp_mem_grewe            = 5;
    TopKCLDrive             topk_cldrive              = 6;
    MutecVsBenchPress       mutec_vs_benchpress       = 7;
    SRCIROR_srcVsBenchPress srciror_src_vs_benchpress = 8;
    SRCIROR_IRVsBenchPress  srciror_ir_vs_benchpress  = 9;
    GenerateCLSmith         generate_clsmith          = 10;
    GreweTopKCSV            grewe_top_k_csv           = 11;
    GreweCSV                grewe_csv                 = 12;
  }
}

// 1
// Dump log file for all databases provided.
message LogFile {
  optional string          target    = 1;
  repeated DatabasesGroups db_group  = 2;
}

// 2
// Calculate and plot the average score of the top-K best samples per target from each DB group.
message KAverageScore {
  optional string               target        = 1;
  optional string               feature_space = 2;
  optional int32                top_k         = 3;
  repeated DatabasesGroups      db_group      = 4;
  optional PlotterConfiguration plot_config   = 5;
}

// 3
// Calculate and plot the minimum score from each DB group for every target benchmark.
message MinScore {
  optional string               target        = 1;
  optional string               feature_space = 2;
  repeated DatabasesGroups      db_group      = 3;
  optional PlotterConfiguration plot_config   = 4;
}

// 4
// Analyze the size of target bechmraks in number of instructions and token length.
message AnalyzeTarget {
  repeated string               target      = 1;
  optional PlotterConfiguration plot_config = 2;
}

// 5
// Map on 2-Dimensional space the number of memory vs computational instructions from Grewe's features.
message CompMemGrewe {
  optional string               target      = 1;
  repeated DatabasesGroups      db_group    = 2;
  optional PlotterConfiguration plot_config = 3;
}

// 6
// Collect CPU vs GPU labels for 
message TopKCLDrive {
  optional string               target        = 1;
  optional string               cldrive_cache = 2;
  optional string               feature_space = 3;
  optional int32                top_k         = 4;
  repeated DatabasesGroups      db_group      = 5;
  optional PlotterConfiguration plot_config   = 6;
}

// 7
// Calculate and plot the average score of the top-K best samples per target from each DB group.
message MutecVsBenchPress {
  optional string               target        = 1;
  optional string               feature_space = 2;
  optional int32                top_k         = 3;
  optional int32                beam_width    = 4;
  optional string               mutec_cache   = 5;
  optional DatabasesGroups      seed          = 6;
  optional DatabasesGroups      benchpress    = 7;
  optional PlotterConfiguration plot_config   = 8;
  optional DatabasesGroups      db_group      = 9; // Dummy selector, not used.
}

// 8
// Calculate and plot the average score of the top-K best samples per target from each DB group.
message SRCIROR_srcVsBenchPress {
  optional string               target            = 1;
  optional string               feature_space     = 2;
  optional int32                top_k             = 3;
  optional int32                beam_width        = 4;
  optional string               srciror_src_cache = 5;
  optional DatabasesGroups      seed              = 6;
  optional DatabasesGroups      benchpress        = 7;
  optional PlotterConfiguration plot_config       = 8;
  optional DatabasesGroups      db_group          = 9; // Dummy selector, not used.
}

// 9
// Calculate and plot the average score of the top-K best samples per target from each DB group.
message SRCIROR_IRVsBenchPress {
  optional string               target           = 1;
  optional string               feature_space    = 2;
  optional int32                top_k            = 3;
  optional int32                beam_width       = 4;
  optional string               srciror_ir_cache = 5;
  optional DatabasesGroups      seed             = 6;
  optional DatabasesGroups      benchpress       = 7;
  optional PlotterConfiguration plot_config      = 8;
  optional DatabasesGroups      db_group         = 9; // Dummy selector, not used.
}

// 10
// Generate CLSmith samples.
message GenerateCLSmith {
  optional string clsmith_db = 1;
}

// 11
// Calculate top samples to target per db group and store to csv for Grewe's predictive model.
message GreweTopKCSV {
  optional string          target        = 1;
  optional string          cldrive_cache = 2;
  optional int32           top_k         = 3;
  repeated DatabasesGroups db_group      = 4;
}

// 12
// Convert databases per db group to CSV for Grewe's predictive model.
message GreweCSV {
  optional string          cldrive_cache = 1;
  repeated DatabasesGroups db_group      = 2;
}

// Define a group of Databases that will be considered jointly.
message DatabasesGroups {
  optional string group_name = 1;
  optional string db_type    = 2;
  repeated string database   = 3;
  // Length of datapoint threshold.
  optional int32  size_limit = 4;
}

// Plot configurations
message PlotterConfiguration {
  optional string title      = 1;
  optional string x_name     = 2;
  optional string y_name     = 3;
  
  optional int32 titlefont   = 4;
  optional int32 axisfont    = 5;
  optional int32 tickfont    = 6;

  optional bool showline     = 7;
  optional string linecolor  = 8;
  optional string gridcolor  = 9;
  optional bool mirror       = 10;
  optional bool showgrid     = 11;
  optional int32 linewidth   = 12;
  optional int32 gridwidth   = 13;
  optional string margin     = 14;

  optional float legend_x    = 15;
  optional float legend_y    = 16;
  optional string traceorder = 17;
  optional int32 legendfont  = 18;

  optional string bg_color   = 19;

  optional int32 height      = 20;
  optional int32 width       = 21;
}
